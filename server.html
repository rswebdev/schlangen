<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake.io - Server</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #0a0a2e;
    color: #e0e0e0;
    min-height: 100vh;
  }
  .dashboard {
    max-width: 700px;
    margin: 0 auto;
    padding: 30px 20px;
  }
  h1 {
    text-align: center;
    font-size: 32px;
    margin-bottom: 8px;
    color: #00ff88;
    text-shadow: 0 0 20px rgba(0,255,136,0.3);
  }
  .server-subtitle {
    text-align: center;
    color: rgba(255,255,255,0.4);
    font-size: 13px;
    margin-bottom: 30px;
  }
  h2 {
    font-size: 14px;
    color: #00cc88;
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .panel {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 16px;
  }
  textarea {
    width: 100%;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    background: rgba(0,0,0,0.4);
    color: #0f0;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 8px;
    resize: none;
    margin: 8px 0;
  }
  button {
    padding: 10px 22px;
    font-size: 13px;
    background: linear-gradient(135deg, #00cc88, #00aa66);
    border: none;
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
    font-weight: bold;
    margin: 4px 2px;
    transition: filter 0.15s;
  }
  button:hover { filter: brightness(1.15); }
  button:disabled { opacity: 0.35; cursor: default; filter: none; }
  button.secondary { background: rgba(255,255,255,0.1); }
  .label {
    color: rgba(255,255,255,0.45);
    font-size: 13px;
    margin: 12px 0 4px;
  }
  .invite-status {
    color: rgba(255,255,255,0.55);
    font-size: 13px;
    margin-bottom: 10px;
  }
  .stat-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  .stat-card {
    background: rgba(0,0,0,0.25);
    border-radius: 8px;
    padding: 14px;
    text-align: center;
  }
  .stat-value {
    font-size: 28px;
    font-weight: bold;
    color: #00ff88;
  }
  .stat-label {
    font-size: 11px;
    color: rgba(255,255,255,0.4);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 4px;
  }
  .player-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background: rgba(0,0,0,0.2);
    border-radius: 8px;
    margin-bottom: 6px;
  }
  .player-name { font-weight: bold; font-size: 14px; }
  .player-score { color: rgba(255,255,255,0.5); font-size: 13px; }
  .player-badge {
    font-size: 11px;
    padding: 2px 10px;
    border-radius: 10px;
    font-weight: bold;
  }
  .badge-alive { background: rgba(0,255,136,0.15); color: #00ff88; }
  .badge-dead { background: rgba(255,68,68,0.15); color: #ff4444; }
  .no-players { color: rgba(255,255,255,0.25); font-style: italic; padding: 10px 0; }
  #server-log {
    max-height: 180px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    background: rgba(0,0,0,0.3);
    border-radius: 8px;
    padding: 10px;
  }
  .log-entry { padding: 2px 0; color: rgba(255,255,255,0.45); }
  .log-time { color: rgba(255,255,255,0.25); }
  #answer-section { display: none; }
  .btn-row { display: flex; gap: 8px; flex-wrap: wrap; }
</style>
</head>
<body>
<div class="dashboard">
  <h1>Snake.io Server</h1>
  <div class="server-subtitle">Game simulation running in this browser tab &mdash; keep it open</div>

  <div class="panel">
    <h2>Invite Players</h2>
    <div class="invite-status" id="invite-status">Click "Generate Invite" to create a connection code</div>
    <div class="btn-row">
      <button id="gen-invite-btn">Generate Invite</button>
    </div>
    <textarea id="offer-text" readonly rows="3" placeholder="Invite code appears here..." style="display:none"></textarea>
    <div class="btn-row" id="offer-btns" style="display:none">
      <button id="copy-offer-btn">Copy Code</button>
    </div>
    <div id="answer-section">
      <div class="label">Paste the player's response code:</div>
      <textarea id="answer-input" rows="3" placeholder="Paste response code here..."></textarea>
      <div class="btn-row">
        <button id="accept-btn">Accept Connection</button>
        <button class="secondary" id="cancel-invite-btn">Cancel</button>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>Game Stats</h2>
    <div class="stat-grid">
      <div class="stat-card"><div class="stat-value" id="stat-players">0</div><div class="stat-label">Players</div></div>
      <div class="stat-card"><div class="stat-value" id="stat-ai">0</div><div class="stat-label">AI Snakes</div></div>
      <div class="stat-card"><div class="stat-value" id="stat-snakes">0</div><div class="stat-label">Alive</div></div>
      <div class="stat-card"><div class="stat-value" id="stat-foods">0</div><div class="stat-label">Foods</div></div>
    </div>
  </div>

  <div class="panel">
    <h2>Connected Players</h2>
    <div id="player-list"><div class="no-players">No players connected yet</div></div>
  </div>

  <div class="panel">
    <h2>Server Log</h2>
    <div id="server-log"></div>
  </div>
</div>

<script>
// ============================================================
// GAME CONSTANTS (must match client)
// ============================================================
const WORLD_SIZE = 5000;
const FOOD_COUNT = 800;
const AI_COUNT = 15;
const BASE_SPEED = 3.2;
const BOOST_SPEED = 5.5;
const SEGMENT_SPACING = 8;
const BASE_SNAKE_LENGTH = 10;
const HEAD_RADIUS = 12;
const BODY_RADIUS = 10;
const TURN_SPEED = 0.08;
const MAX_BOOST = 100;
const BOOST_DRAIN = 0.6;
const BOOST_REGEN = 0.15;
const FOOD_RADIUS = 6;
const FOOD_VALUE = 1;
const KILL_FOOD_COUNT = 8;
const BOUNDARY_MARGIN = 50;

const AI_NAMES = [
  "Viper","Cobra","Mamba","Python","Anaconda",
  "Rattler","Boa","Adder","Asp","Krait",
  "Taipan","Coral","Sidewinder","Copperhead","King",
  "Noodle","Slinky","Wiggles","Scales","Slithers",
  "Fangs","Hissy","Sssnake","Danger","Nope Rope"
];
const SNAKE_COLORS = [
  {h:'#ff4466',b:'#cc2244'},{h:'#44bbff',b:'#2299dd'},
  {h:'#44ff88',b:'#22cc66'},{h:'#ffaa22',b:'#dd8800'},
  {h:'#ff66ff',b:'#cc44cc'},{h:'#ffff44',b:'#cccc22'},
  {h:'#ff8844',b:'#cc6622'},{h:'#88ffff',b:'#66cccc'},
  {h:'#aa88ff',b:'#8866cc'},{h:'#ff88aa',b:'#cc6688'},
  {h:'#88ff44',b:'#66cc22'},{h:'#44ffcc',b:'#22ccaa'},
];
const FOOD_COLORS = [
  '#ff6b6b','#ee5a24','#ffd32a','#0be881',
  '#18dcff','#7158e2','#ff3838','#3ae374',
  '#ff9f43','#a55eea','#ff6348','#2ed573',
];

// ============================================================
// GAME STATE
// ============================================================
let snakes = [];
let foods = [];
let frameCount = 0;

// ============================================================
// NETWORK STATE
// ============================================================
const RTC_CONFIG = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
  ]
};
const NET_TICK_RATE = 4;
const FOOD_SYNC_INTERVAL = 10;
let peers = [];
let nextPlayerId = 1;
let netTick = 0;
let pendingPeer = null;

// ============================================================
// UTILITY FUNCTIONS
// ============================================================
function rand(min, max) { return Math.random() * (max - min) + min; }
function randInt(min, max) { return Math.floor(rand(min, max)); }
function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
function angleTo(x1, y1, x2, y2) { return Math.atan2(y2-y1, x2-x1); }
function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
function angleDiff(a, b) {
  let d = b - a;
  while (d > Math.PI) d -= Math.PI * 2;
  while (d < -Math.PI) d += Math.PI * 2;
  return d;
}
function randWorldPos() {
  const m = 200;
  return { x: rand(m, WORLD_SIZE - m), y: rand(m, WORLD_SIZE - m) };
}
function pickRandom(arr) { return arr[randInt(0, arr.length)]; }
function getSnakeHeadRadius(s) { return HEAD_RADIUS + Math.min(s.segments.length * 0.03, 6); }
function getSnakeBodyRadius(s) { return BODY_RADIUS + Math.min(s.segments.length * 0.025, 5); }

// ============================================================
// SNAKE
// ============================================================
function createSnake(name, x, y, color, isAI) {
  const angle = rand(0, Math.PI * 2);
  const segments = [];
  for (let i = 0; i < BASE_SNAKE_LENGTH; i++) {
    segments.push({ x: x - Math.cos(angle) * SEGMENT_SPACING * i, y: y - Math.sin(angle) * SEGMENT_SPACING * i });
  }
  return {
    name, segments, angle, targetAngle: angle, speed: BASE_SPEED, color, isAI,
    isPlayer: !isAI, playerId: -1,
    score: 0, targetLength: BASE_SNAKE_LENGTH, boost: MAX_BOOST, isBoosting: false, alive: true,
    aiTimer: 0, aiTargetAngle: angle, aiState: 'wander', aiStateTimer: 0, invincibleTimer: 120,
    aiTarget: null,
  };
}

function growSnake(s, amt) { s.targetLength += amt; s.score += amt; }

function updateSnake(snake) {
  if (!snake.alive) return;
  if (snake.invincibleTimer > 0) snake.invincibleTimer--;

  const diff = angleDiff(snake.angle, snake.targetAngle);
  snake.angle += clamp(diff, -TURN_SPEED, TURN_SPEED) * 1.8;

  if (snake.isBoosting && snake.boost > 0 && snake.segments.length > 12) {
    snake.speed = BOOST_SPEED;
    snake.boost -= BOOST_DRAIN;
    if (frameCount % 8 === 0 && snake.targetLength > BASE_SNAKE_LENGTH) {
      snake.targetLength -= 1;
      const tail = snake.segments[snake.segments.length - 1];
      spawnFood(tail.x + rand(-10,10), tail.y + rand(-10,10));
    }
  } else {
    snake.speed = BASE_SPEED;
    snake.isBoosting = false;
    if (snake.boost < MAX_BOOST) snake.boost += BOOST_REGEN;
  }

  const head = snake.segments[0];
  const newX = head.x + Math.cos(snake.angle) * snake.speed;
  const newY = head.y + Math.sin(snake.angle) * snake.speed;

  if (newX < BOUNDARY_MARGIN || newX > WORLD_SIZE - BOUNDARY_MARGIN ||
      newY < BOUNDARY_MARGIN || newY > WORLD_SIZE - BOUNDARY_MARGIN) {
    if (snake.isPlayer) { killSnake(snake); return; }
    else { snake.targetAngle = angleTo(head.x, head.y, WORLD_SIZE/2, WORLD_SIZE/2); return; }
  }

  snake.segments.unshift({ x: newX, y: newY });
  while (snake.segments.length > snake.targetLength) snake.segments.pop();
}

function killSnake(snake) {
  if (!snake.alive) return;
  snake.alive = false;
  const step = Math.max(1, Math.floor(snake.segments.length / KILL_FOOD_COUNT));
  for (let i = 0; i < snake.segments.length; i += step) {
    const seg = snake.segments[i];
    spawnFood(seg.x + rand(-15,15), seg.y + rand(-15,15), true);
  }
  addLog(snake.name + ' died (score: ' + snake.score + ')');
  if (snake.isAI) {
    setTimeout(() => respawnAI(snake), 3000);
  }
}

function respawnAI(snake) {
  const idx = snakes.indexOf(snake);
  if (idx < 0) return;
  const pos = randWorldPos();
  const newSnake = createSnake(snake.name, pos.x, pos.y, pickRandom(SNAKE_COLORS), true);
  const extra = randInt(0, 40);
  newSnake.targetLength += extra;
  newSnake.score += extra;
  snakes[idx] = newSnake;
}

// ============================================================
// AI
// ============================================================
function updateAI(snake) {
  if (!snake.alive || !snake.isAI) return;
  snake.aiStateTimer--;
  const head = snake.segments[0];

  if (head.x < 300 || head.x > WORLD_SIZE-300 || head.y < 300 || head.y > WORLD_SIZE-300) {
    snake.aiState = 'flee_boundary'; snake.aiStateTimer = 30;
  }
  if (snake.aiStateTimer <= 0) {
    const r = Math.random();
    if (r < 0.5) { snake.aiState = 'seek_food'; snake.aiStateTimer = randInt(60,180); }
    else if (r < 0.8) { snake.aiState = 'wander'; snake.aiStateTimer = randInt(60,150); snake.aiTargetAngle = rand(0, Math.PI*2); }
    else { snake.aiState = 'hunt'; snake.aiStateTimer = randInt(90,200); }
  }

  switch (snake.aiState) {
    case 'flee_boundary':
      snake.targetAngle = angleTo(head.x, head.y, WORLD_SIZE/2, WORLD_SIZE/2) + rand(-0.3,0.3);
      snake.isBoosting = true; break;
    case 'seek_food': {
      let closest = null, cd = 400;
      for (const f of foods) { const d = dist(head.x,head.y,f.x,f.y); if (d < cd) { cd = d; closest = f; } }
      if (closest) snake.targetAngle = angleTo(head.x, head.y, closest.x, closest.y);
      else { snake.aiState = 'wander'; snake.aiStateTimer = randInt(60,120); }
      snake.isBoosting = false; break;
    }
    case 'hunt': {
      let target = null, td = 500;
      for (const o of snakes) {
        if (o === snake || !o.alive || o.segments.length > snake.segments.length*1.5) continue;
        const d = dist(head.x,head.y,o.segments[0].x,o.segments[0].y);
        if (d < td) { td = d; target = o; }
      }
      if (target) {
        const th = target.segments[0];
        snake.targetAngle = angleTo(head.x, head.y, th.x + Math.cos(target.angle)*100, th.y + Math.sin(target.angle)*100);
        snake.isBoosting = td < 200 && snake.boost > 30;
      } else snake.aiState = 'wander';
      break;
    }
    default:
      if (frameCount % 60 === 0) snake.aiTargetAngle += rand(-0.8,0.8);
      snake.targetAngle = snake.aiTargetAngle;
      snake.isBoosting = false; break;
  }

  // Collision avoidance
  for (const o of snakes) {
    if (o === snake || !o.alive) continue;
    for (let i = 0; i < Math.min(o.segments.length,40); i += 2) {
      const seg = o.segments[i];
      const d = dist(head.x, head.y, seg.x, seg.y);
      const ad = getSnakeBodyRadius(o) + getSnakeHeadRadius(snake) + 30;
      if (d < ad) {
        snake.targetAngle = angleTo(seg.x, seg.y, head.x, head.y);
        snake.isBoosting = d < ad * 0.6 && snake.boost > 20;
        break;
      }
    }
  }
}

// ============================================================
// FOOD
// ============================================================
function spawnFood(x, y, large) {
  if (x === undefined) { const p = randWorldPos(); x = p.x; y = p.y; }
  foods.push({ x, y, color: pickRandom(FOOD_COLORS),
    radius: large ? rand(7,11) : FOOD_RADIUS,
    value: large ? rand(2,5) : FOOD_VALUE,
  });
}
function initFoods() { foods = []; for (let i = 0; i < FOOD_COUNT; i++) spawnFood(); }

function checkFoodCollision(snake) {
  if (!snake.alive) return;
  const head = snake.segments[0];
  const hr = getSnakeHeadRadius(snake);
  for (let i = foods.length-1; i >= 0; i--) {
    const f = foods[i];
    if (dist(head.x, head.y, f.x, f.y) < hr + f.radius) {
      growSnake(snake, Math.round(f.value));
      foods.splice(i, 1);
    }
  }
}

// ============================================================
// COLLISIONS
// ============================================================
function checkSnakeCollisions() {
  for (const s of snakes) {
    if (!s.alive || s.invincibleTimer > 0) continue;
    const head = s.segments[0], hr = getSnakeHeadRadius(s);
    for (const o of snakes) {
      if (o === s || !o.alive) continue;
      const br = getSnakeBodyRadius(o);
      for (let i = 5; i < o.segments.length; i++) {
        if (dist(head.x, head.y, o.segments[i].x, o.segments[i].y) < hr + br - 4) {
          killSnake(s);
          growSnake(o, Math.round(s.segments.length * 0.3));
          break;
        }
      }
      if (!s.alive) break;
    }
  }
}

// ============================================================
// BINARY SERIALIZATION
// ============================================================
const textEncoder = new TextEncoder();

function serializeStateBinary(includeFood) {
  let size = 4; // header: type(1) + flags(1) + snakeCount(2)
  const nameCache = [];
  for (const s of snakes) {
    const nb = textEncoder.encode(s.name);
    nameCache.push(nb);
    const segCount = Math.ceil(s.segments.length / 2);
    size += 1 + nb.length + 1 + 1 + 2 + 2 + 1 + 2 + 1 + 1 + 2 + segCount * 4;
  }
  if (includeFood) {
    size += 2 + foods.length * 7;
  }

  const buf = new ArrayBuffer(size);
  const view = new DataView(buf);
  const bytes = new Uint8Array(buf);
  let o = 0;

  view.setUint8(o++, 1); // type = state
  view.setUint8(o++, includeFood ? 1 : 0);
  view.setUint16(o, snakes.length); o += 2;

  for (let si = 0; si < snakes.length; si++) {
    const s = snakes[si];
    const nb = nameCache[si];
    view.setUint8(o++, nb.length);
    bytes.set(nb, o); o += nb.length;

    view.setUint8(o++, SNAKE_COLORS.indexOf(s.color));
    let flags = 0;
    if (s.alive) flags |= 1;
    if (s.isBoosting) flags |= 2;
    if (s.isPlayer) flags |= 4;
    view.setUint8(o++, flags);

    view.setUint16(o, Math.min(s.score, 65535)); o += 2;
    let a = s.angle;
    while (a > Math.PI) a -= Math.PI * 2;
    while (a < -Math.PI) a += Math.PI * 2;
    view.setInt16(o, Math.round(a * 10000)); o += 2;
    view.setUint8(o++, Math.round(clamp(s.boost, 0, 255)));
    view.setUint16(o, Math.min(s.targetLength, 65535)); o += 2;
    view.setInt8(o++, s.playerId);
    view.setUint8(o++, Math.round(clamp(s.invincibleTimer, 0, 255)));

    const segCount = Math.ceil(s.segments.length / 2);
    view.setUint16(o, segCount); o += 2;
    for (let i = 0; i < s.segments.length; i += 2) {
      view.setUint16(o, Math.round(clamp(s.segments[i].x, 0, 65535))); o += 2;
      view.setUint16(o, Math.round(clamp(s.segments[i].y, 0, 65535))); o += 2;
    }
  }

  if (includeFood) {
    view.setUint16(o, foods.length); o += 2;
    for (const f of foods) {
      view.setUint16(o, Math.round(clamp(f.x, 0, 65535))); o += 2;
      view.setUint16(o, Math.round(clamp(f.y, 0, 65535))); o += 2;
      view.setUint8(o++, FOOD_COLORS.indexOf(f.color));
      view.setUint8(o++, Math.round(clamp(f.radius * 10, 0, 255)));
      view.setUint8(o++, Math.round(clamp(f.value * 10, 0, 255)));
    }
  }

  return buf;
}

function broadcastState(includeFood) {
  const connected = peers.filter(p => p.connected);
  if (connected.length === 0) return;

  const buf = serializeStateBinary(includeFood);
  for (const peer of connected) {
    if (peer.dc && peer.dc.readyState === 'open') {
      try { peer.dc.send(buf); } catch (e) {}
    }
  }
}

// ============================================================
// WEBRTC SERVER
// ============================================================
async function generateInvite() {
  if (pendingPeer) {
    addLog('Cancel the current invite first.');
    return;
  }

  const pc = new RTCPeerConnection(RTC_CONFIG);
  const dc = pc.createDataChannel('game', { ordered: true });
  dc.binaryType = 'arraybuffer';

  const playerId = nextPlayerId++;
  const peer = {
    pc, dc, playerId,
    playerName: 'Player ' + playerId,
    snake: null,
    inputAngle: 0,
    inputBoosting: false,
    connected: false,
  };

  dc.onopen = () => {
    peer.connected = true;
    dc.send(JSON.stringify({ t: 'welcome', pid: playerId }));
    addLog('Data channel opened for Player ' + playerId);
    updateDashboard();
  };

  dc.onmessage = (e) => {
    if (typeof e.data === 'string') {
      handlePeerMessage(peer, e.data);
    } else {
      const view = new DataView(e.data);
      if (view.getUint8(0) === 2) {
        peer.inputAngle = view.getInt16(1) / 10000;
        peer.inputBoosting = (view.getUint8(3) & 1) !== 0;
      }
    }
  };
  dc.onclose = () => handlePeerDisconnect(peer);

  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
      handlePeerDisconnect(peer);
    }
  };

  pc.onicecandidate = (e) => {
    if (e.candidate === null) {
      const offerB64 = btoa(JSON.stringify(pc.localDescription));
      document.getElementById('offer-text').value = offerB64;
      document.getElementById('offer-text').style.display = 'block';
      document.getElementById('offer-btns').style.display = 'flex';
      document.getElementById('answer-section').style.display = 'block';
      document.getElementById('invite-status').textContent = 'Copy the code and send it to a player. Then paste their response below.';
      addLog('Invite code generated for Player ' + playerId);
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  peers.push(peer);
  pendingPeer = peer;

  document.getElementById('invite-status').textContent = 'Generating invite code...';
  document.getElementById('gen-invite-btn').disabled = true;
}

async function acceptAnswer() {
  const answerB64 = document.getElementById('answer-input').value.trim();
  if (!answerB64 || !pendingPeer) return;

  try {
    const answer = JSON.parse(atob(answerB64));
    await pendingPeer.pc.setRemoteDescription(answer);
    document.getElementById('invite-status').textContent = 'Connecting...';
    addLog('Accepted answer for Player ' + pendingPeer.playerId);
  } catch (e) {
    document.getElementById('invite-status').textContent = 'Invalid response code. Check and try again.';
    addLog('Error: Invalid answer code');
  }
}

function cancelInvite() {
  if (pendingPeer) {
    pendingPeer.pc.close();
    const idx = peers.indexOf(pendingPeer);
    if (idx >= 0) peers.splice(idx, 1);
    pendingPeer = null;
    addLog('Invite cancelled');
  }
  resetInvitePanel();
}

function handlePeerDisconnect(peer) {
  if (!peer.connected) return;
  peer.connected = false;

  if (peer.snake) {
    const idx = snakes.indexOf(peer.snake);
    if (idx >= 0) {
      snakes.splice(idx, 1);
      // Replace with AI
      const pos = randWorldPos();
      const name = pickRandom(AI_NAMES);
      const ai = createSnake(name, pos.x, pos.y, pickRandom(SNAKE_COLORS), true);
      const extra = randInt(0, 40);
      ai.targetLength += extra;
      ai.score += extra;
      snakes.push(ai);
    }
    peer.snake = null;
  }

  addLog(peer.playerName + ' disconnected');
  updateDashboard();
}

function handlePeerMessage(peer, data) {
  try {
    const msg = JSON.parse(data);
    switch (msg.t) {
      case 'join':
        peer.playerName = msg.name || peer.playerName;
        spawnPlayerSnake(peer);
        addLog(peer.playerName + ' joined the game');
        peer.dc.send(serializeStateBinary(true));
        updateDashboard();
        resetInvitePanel();
        break;

      case 'respawn':
        if (peer.snake && !peer.snake.alive) {
          respawnPlayerSnake(peer);
          addLog(peer.playerName + ' respawned');
        }
        break;
    }
  } catch (e) {}
}

function spawnPlayerSnake(peer) {
  // Remove one AI to make room
  const aiIdx = snakes.findIndex(s => s.isAI && s.alive);
  if (aiIdx >= 0) snakes.splice(aiIdx, 1);

  const pos = randWorldPos();
  const snake = createSnake(peer.playerName, pos.x, pos.y, pickRandom(SNAKE_COLORS), false);
  snake.playerId = peer.playerId;
  peer.snake = snake;
  snakes.push(snake);
}

function respawnPlayerSnake(peer) {
  const idx = snakes.indexOf(peer.snake);
  if (idx >= 0) snakes.splice(idx, 1);

  const pos = randWorldPos();
  const snake = createSnake(peer.playerName, pos.x, pos.y, pickRandom(SNAKE_COLORS), false);
  snake.playerId = peer.playerId;
  snake.invincibleTimer = 120;
  peer.snake = snake;
  snakes.push(snake);
}

// ============================================================
// GAME LOOP
// ============================================================
function gameLoop() {
  frameCount++;

  // Apply player inputs
  for (const peer of peers) {
    if (!peer.connected || !peer.snake || !peer.snake.alive) continue;
    peer.snake.targetAngle = peer.inputAngle;
    peer.snake.isBoosting = peer.inputBoosting;
  }

  // Update all snakes
  for (const snake of snakes) {
    if (!snake.alive) continue;
    if (snake.isAI) updateAI(snake);
    updateSnake(snake);
    checkFoodCollision(snake);
  }

  checkSnakeCollisions();
  while (foods.length < FOOD_COUNT) spawnFood();

  // Broadcast state to clients
  if (frameCount % NET_TICK_RATE === 0) {
    netTick++;
    const includeFood = netTick % FOOD_SYNC_INTERVAL === 0;
    broadcastState(includeFood);
  }

  // Update dashboard
  if (frameCount % 60 === 0) updateDashboard();
}

// ============================================================
// DASHBOARD
// ============================================================
function updateDashboard() {
  const connected = peers.filter(p => p.connected && p.snake);
  const aiCount = snakes.filter(s => s.isAI).length;

  document.getElementById('stat-players').textContent = connected.length;
  document.getElementById('stat-ai').textContent = aiCount;
  document.getElementById('stat-snakes').textContent = snakes.filter(s => s.alive).length;
  document.getElementById('stat-foods').textContent = foods.length;

  const list = document.getElementById('player-list');
  if (connected.length === 0) {
    list.innerHTML = '<div class="no-players">No players connected yet</div>';
    return;
  }
  list.innerHTML = '';
  for (const peer of connected) {
    const s = peer.snake;
    const div = document.createElement('div');
    div.className = 'player-item';
    div.innerHTML =
      '<span class="player-name" style="color:' + s.color.h + '">' + peer.playerName + '</span>' +
      '<span class="player-score">Score: ' + s.score + ' | Len: ' + s.segments.length + '</span>' +
      '<span class="player-badge ' + (s.alive ? 'badge-alive' : 'badge-dead') + '">' + (s.alive ? 'Alive' : 'Dead') + '</span>';
    list.appendChild(div);
  }
}

function addLog(message) {
  const log = document.getElementById('server-log');
  const time = new Date().toLocaleTimeString();
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.innerHTML = '<span class="log-time">[' + time + ']</span> ' + message;
  log.appendChild(entry);
  log.scrollTop = log.scrollHeight;
  while (log.children.length > 100) log.removeChild(log.firstChild);
}

function resetInvitePanel() {
  document.getElementById('offer-text').value = '';
  document.getElementById('offer-text').style.display = 'none';
  document.getElementById('offer-btns').style.display = 'none';
  document.getElementById('answer-input').value = '';
  document.getElementById('answer-section').style.display = 'none';
  document.getElementById('invite-status').textContent = 'Click "Generate Invite" to create a connection code';
  document.getElementById('gen-invite-btn').disabled = false;
  pendingPeer = null;
}

// ============================================================
// INIT
// ============================================================
function startServer() {
  initFoods();

  const usedNames = new Set();
  for (let i = 0; i < AI_COUNT; i++) {
    let name; do { name = pickRandom(AI_NAMES); } while (usedNames.has(name));
    usedNames.add(name);
    const pos = randWorldPos();
    const snake = createSnake(name, pos.x, pos.y, SNAKE_COLORS[i % SNAKE_COLORS.length], true);
    const extra = randInt(0, 40);
    snake.targetLength += extra;
    snake.score += extra;
    snakes.push(snake);
  }

  // Use a Web Worker timer to avoid background-tab throttling
  try {
    const timerBlob = new Blob(
      ['setInterval(()=>self.postMessage(0),' + Math.round(1000/60) + ')'],
      { type: 'text/javascript' }
    );
    const timerWorker = new Worker(URL.createObjectURL(timerBlob));
    timerWorker.onmessage = gameLoop;
    addLog('Server started (Web Worker timer — background-safe)');
  } catch (e) {
    setInterval(gameLoop, Math.round(1000/60));
    addLog('Server started (setInterval fallback — keep tab focused)');
  }

  updateDashboard();
  addLog('Game running with ' + AI_COUNT + ' AI snakes');
}

// Event bindings
document.getElementById('gen-invite-btn').addEventListener('click', generateInvite);
document.getElementById('copy-offer-btn').addEventListener('click', () => {
  const text = document.getElementById('offer-text').value;
  navigator.clipboard.writeText(text).then(() => {
    document.getElementById('copy-offer-btn').textContent = 'Copied!';
    setTimeout(() => document.getElementById('copy-offer-btn').textContent = 'Copy Code', 2000);
  });
});
document.getElementById('accept-btn').addEventListener('click', acceptAnswer);
document.getElementById('cancel-invite-btn').addEventListener('click', cancelInvite);

// Start
startServer();
</script>
</body>
</html>
